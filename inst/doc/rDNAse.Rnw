\documentclass[shortnames,nojss,notitle,article]{jss}
\usepackage{booktabs}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tablefootnote}
\usepackage[utf8]{inputenc}
%\VignetteIndexEntry{rDNAse: R package  for generating various numerical representation schemes of DNA sequences}
%\VignetteKeywords{R, rDNAse, DNA sequence, DNA, descriptor calculation, feature extraction, parallel computation, structural similarity, functional similarity, sequence alignment, Gene Ontology, GO}
%\VignettePackage{rDNAse}

% header and footer
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE]{The \pkg{rDNAse} Manual}
\fancyhead[RO]{The \pkg{rDNAse} Manual}
\fancyhead[RE]{}
\fancyhead[LO]{}
\cfoot{\thepage}

\author{Min-feng Zhu\\Central South University \And
        Jie Dong\\Central South University \And
        Dong-Sheng Cao\\Central South University}
\Plainauthor{Min-feng Zhu, Jie Dong, Dong-Sheng Cao}

\title{\pkg{rDNAse}: \proglang{R} package for generating various numerical representation schemes of DNA sequences}
\Plaintitle{rDNAse: R package for generating various numerical representation schemes of DNA sequences}

\Volume{xx}
\Issue{x}
\Month{Xxxxx}
\Year{2016}
\Submitdate{2016-xx-xx}
\Acceptdate{2016-xx-xx}

\Address{
  Min-feng Zhu \\
  the third xiangya hospital\\
  School of Pharmaceutical Sciences\\
  Central South University\\
  Changsha, Hunan, P. R. China\\
  E-mail: \email{wind2zhu@163.com}\\

  Jie Dong\\
  School of Pharmaceutical Sciences\\
  Central South University\\
  Changsha, Hunan, P. R. China\\
  E-mail: \email{biomed@csu.edu.cn}\\

  Dong-Sheng Cao\\
  School of Pharmaceutical Sciences\\
  Central South University\\
  Changsha, Hunan, P. R. China\\
  E-mail: \email{oriental-cds@163.com}

}

%
<<prelim,echo=FALSE,print=FALSE>>=
rDNAse.version = '1.1-0'
now.date = strftime(Sys.Date(), "%Y-%m-%d")
@
%

\begin{document}
%\SweaveOpts{concordance=TRUE}

    \begin{center}
    \vspace*{\baselineskip}
    \rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
    \rule{\textwidth}{0.4pt}\\[2\baselineskip]
    {\LARGE \pkg{rDNAse}\textbf{: \proglang{R} package for generating various numerical representation schemes of DNA sequences}}\\[1.2\baselineskip]
    \rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
    \rule{\textwidth}{1.6pt}\\[2\baselineskip]
    {\Large Min-feng Zhu, Jie Dong, Dong-Sheng Cao}\\[\baselineskip]
    {\large Package Version: \Sexpr{rDNAse.version}}\par
    {\large \Sexpr{now.date}}\par
    \vfill
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{fig/logo-panel-text.pdf}
    \end{figure}

%    {\scshape Computational Biology and Drug Design Group} \\
%    {\scshape Central South University, China}\par
    \end{center}

\thispagestyle{empty}

\clearpage

\tableofcontents

\thispagestyle{empty}

\clearpage

\setcounter{page}{1}

\begin{center}
\textbf{Abstract}
\end{center}

The rDNAse \proglang{R} package can generate various feature vectors for DNA sequences, this \proglang{R} package could:
1) Calculate three nucleic acid composition features describing the local sequence information by means of kmers (subsequences of DNA sequences);
2) Calculate six autocorrelation features describing the level of correlation between two oligonucleotides along a DNA sequence in terms of their specific physicochemical properties;
3) Calculate six pseudo nucleotide composition features, which can be used to represent a DNA sequence with a discrete model or vector yet still keep considerable sequence order information, particularly the global or long-range sequence order information, via the physicochemical properties of its constituent oligonucleotides.
There are five modules in the \pkg{rDNAse} package, including basic tools, nucleic acid composition, autocorrelation, pseudo nucleotide composition and  similarity calculation. The basic tools module contains several basic functions manipulating DNA data, including reading DNA data from files or list (a data structure in \proglang{R}), checking the validity and  get DNA sequences from Genbank by GI ID(s), etc. The three modules nucleic acid composition, autocorrelation, pseudo nucleotide composition  respond to the calculation of 11 different features from three feature categories. The nucleic acid composition aims at computing three types of nucleic acid composition, including basic kmer, reverse compliment kmer and increment of diversity; The autocorrelation aims at computing six types of autocorrelation, including dinucleotide-based auto covariance (DAC), dinucleotide-based cross covariance (DCC), dinucleotide-based auto-cross covariance (DACC), trinucleotide-based auto covariance (TAC), trinucleotide-based cross covariance (TCC), and trinucleotide- based auto-cross covariance (TACC); The pseudo nucleotide composition aims at computing two types of pseudo nucleic acid composition: pseudo dinucleotide composition (PseDNC), pseudo k-tuple nucleotide composition (PseKNC). The similarity calculation module contains  similarity calculation by sequence alignment and GO semantic similarity measures. 


\textbf{Keywords:} DNA sequence, Descriptor, Sequence alignment, Gene Ontology, Sequence features

\section{The Full Workflow Using rDNAse}\addcontentsline{toc}{section}{1. The Full Workflow Using rDNAse}

Here we use the DNaseI HSs in the human genome presented in the study of \cite{noble2005predicting} to demonstrate the full workflow when using rDNAse.

We select two classes of DNA as our benchmark dataset. 280 validated erythroid HS sequences were treated as the positive sample set, 737 validated erythroid HS sequences were treated as the negative sample set. 

First, we load the \pkg{rDNAse} package, then read the DNA sequences stored in two separated FASTA files with \code{readFASTA()}:

\begin{CodeInput}
require(rDNAse)

# load FASTA files
pos_hs = readFASTA(system.file('dnaseq/hs.fasta',
                                   package = 'rDNAse'))
neg_hs = readFASTA(system.file('dnaseq/non-hs.fasta',
                                   package = 'rDNAse'))
\end{CodeInput}

\begin{CodeInput}
length(pos_hs)
\end{CodeInput}

\begin{CodeOutput}
## [1] 280
\end{CodeOutput}

\begin{CodeInput}
length(neg_hs)
\end{CodeInput}

\begin{CodeOutput}
## [1] 737
\end{CodeOutput}

To assure that the DNA sequences only have the dour standard deoxyribonucleic acid  types which is required for the descriptor computation, we use the \code{dnacheck()} function in \pkg{rDNAse} to do the deoxyribonucleic acid  type sanity checking and remove the \emph{non-standard} sequences:

\begin{CodeInput}
pos_hs = pos_hs[(sapply(pso_hs, dnacheck))]
neg_hs = neg_hs[(sapply(neg_hs, dnacheck))]
\end{CodeInput}

\begin{CodeInput}
length(pos_hs)
\end{CodeInput}

\begin{CodeOutput}
## [1] 280
\end{CodeOutput}

\begin{CodeInput}
length(neg_hs)
\end{CodeInput}

\begin{CodeOutput}
## [1] 737
\end{CodeOutput}

For the remaining sequences, we calculate the kmer descriptor, i.e., the kmer descriptor \citep{noble2005predicting} and make class labels for classification modeling.

\begin{CodeInput}
# calculate kmer descriptors
x1 = t(sapply(pos_hs, kmer))
x2 = t(sapply(neg_hs, kmer))
x  = rbind(x1, x2)

# make class labels
labels = as.factor(c(rep(0, length(pos_hs)), rep(1, length(neg_hs))))
\end{CodeInput}

Next, we will split the data into a $75\%$ training set and a $25\%$ test set.

\begin{CodeInput}
# split training and test set
set.seed(1001)
tr.idx = c(sample(1:nrow(x1), round(nrow(x1) * 0.75)),
           sample(nrow(x1) + 1:nrow(x2), round(nrow(x2) * 0.75)))
te.idx = setdiff(1:nrow(x), tr.idx)
x.tr   = x[tr.idx, ]
x.te   = x[te.idx, ]
y.tr   = labels[tr.idx]
y.te   = labels[te.idx]
\end{CodeInput}

We will train a random forest classification model on the training set with 5-fold cross-validation, using the \pkg{randomForest} package.

\begin{CodeInput}
require(randomForest)
rf.fit = randomForest(x.tr, y.tr, cv.fold = 5)
print(rf.fit)
\end{CodeInput}

The training result is:

\begin{CodeOutput}
## Call:
##  randomForest(x = x.tr, y = y.tr, cv.fold = 5) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 4
## 
##         OOB estimate of  error rate: 13.89%
## Confusion matrix:
##     0   1 class.error
## 0 138  72  0.34285714
## 1  34 519  0.06148282
\end{CodeOutput}

With the model trained on the training set, we predict on the test set and plot the ROC curve with the \pkg{pROC} package, as is shown in figure \ref{fig:roc}.

\begin{CodeInput}
# predict on test set
rf.pred = predict(rf.fit, newdata = x.te, type = 'prob')[, 1]

# plot ROC curve
require(pROC)
plot.roc(y.te, rf.pred, col = '#0080ff', grid = TRUE, print.auc = TRUE)
\end{CodeInput}

The area under the ROC curve (AUC) is:

\begin{CodeOutput}
## Call:
## plot.roc.default(x = y.te, predictor = rf.pred, col = "#0080ff",
##                  grid = TRUE, print.auc = TRUE)
##
## Data: rf.pred in 70 controls (y.te 0) > 184 cases (y.te 1).
## Area under the curve: 0.7799
\end{CodeOutput}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\textwidth]{fig/roc.pdf}
\caption{ROC curve achieved by the predictor based on  kmers for predicting DNaseI HSs in the human genome} \label{fig:roc}
\end{figure}

\section{Package Overview}\label{sec:intro}\addcontentsline{toc}{section}{2. Package Overview}

The \pkg{rDNAse} package is freely available from the Comprehensive \proglang{R} Archive Network (\url{http://CRAN.R-project.org/package=rDNAse}). This vignette corresponds to \pkg{rDNAse} version \Sexpr{rDNAse.version} and was typeset on \Sexpr{now.date}.

The \pkg{rDNAse} computes three feature groups composed of 11 different features, including:


\begin{itemize}
  \item Basic function
  \begin{itemize}
  \item \code{readFASTA()} - Read DNA sequence data from FASTA files
  \end{itemize}
  \item Nucleic acid composition
  \begin{itemize}
  \item \code{kmer()} - Basic kmer and Reverse compliment kmer
  \item \code{make_idkmer_vec()} - Increment of diversity (ID)
  \end{itemize}
  \item Autocorrelation
  \begin{itemize}
  \item \code{extrDAC()} - Dinucleotide-based auto covariance 
  \item \code{extrDCC()} - Dinucleotide-based cross covariance
  \item \code{extrDACC()} - Dinucleotide-based auto-cross covariance
  \item \code{extrTAC()} - Trinucleotide-based auto covariance 
  \item \code{extrTCC()} - Trinucleotide-based cross covariance 
  \item \code{extrDACC()} - Trinucleotide-based auto-cross covariance 
  \end{itemize}
  \item Pseudo nucleotide composition
  \begin{itemize}
  \item \code{extrPseDNC()} - Pseudo dinucleotide composition
  \item \code{extrPseKNC()} - Pseudo k-tupler nucleotide composition
  \end{itemize}
\end{itemize}

The \pkg{rDNAse} package integrates the function of parallelized similarity score computation derived by local or global DNA sequence alignment between a list of DNA sequences, the sequence alignment computation is provided by \pkg{Biostrings}, the corresponding functions listed in the \pkg{rDNAse} package include:

\begin{itemize}
  \item \code{twoSeqSim()} - Similarity calculation derived by sequence alignment between two DNA sequences
\end{itemize}

The \pkg{rDNAse} package also integrates the function of parallelized similarity score computation derived by Gene Ontology (GO) semantic similarity measures between a list of GO terms / Entrez Gene IDs, the GO similarity computation is provided by \pkg{GOSemSim}, the corresponding functions listed in the \pkg{rDNAse} package include:

\begin{itemize}
  \item \code{twoGOSim()} - Similarity calculation derived by GO-terms semantic similarity measures between two GO terms / Entrez Gene IDs
\end{itemize}

In the next sections, we'll introduce the descriptors and function usage in this order.

\section{Commonly Used Descriptors}\label{sec:descriptors}\addcontentsline{toc}{section}{3. Commonly Used Descriptors}

\textbf{Disclaimer.} Users of the \pkg{rDNAse} package need to intelligently evaluate the underlying details of the descriptors provided, instead of using rDNAse with their data blindly, especially for the descriptor types with more flexibility. It would be wise for the users to use some negative and positive control comparisons where relevant to help guide interpretation of the results.

A DNA or deoxyribonucleic acid sequence with $N$ deoxyribonucleic acid could be generally represented as $\{\,R_1, R_2, \ldots, R_n\,\}$, where $R_i$ represents the residue at the $i$-th position in the sequence. The labels $i$ and $j$ are used to index deoxyribonucleic acid position in a sequence, and $r$, $s$, $t$ are used to represent the Deoxyribonucleic acid type . 

A DNA sequence could be divided equally into segments and the methods, described as follows for the global sequence, could be applied to each segment.

\subsection{kmer}\label{subsec:kmer}

Basic kmer is the simplest approach to represent the DNAs, in which the DNA sequences are represented as the occurrence frequencies of k neighboring nucleic acids. This approach has been successfully applied to human gene regulatory sequence prediction \citep{noble2005predicting}, enhancer identification \citep{lee2011discriminative}, etc.

$$
f(r, s) = \frac{N_{rs}}{N - 1} \quad r, s = 1, 2, \ldots, 16.
$$

where $N_{rs}$ is the number of dipeptide represented by deoxyribonucleic acid $r$ and type $s$.  here we use \code{kmer()} to compute the descriptors:

%
<<kmer>>=
require(rDNAse)
x = "AATTCATGCGTCCGGACTTCTGCCTCGAGCCGCCGTACACTGGGCCCTGCAAAGCTC"
kmer(x)
@
%

if reverse is TRUE, we can use \code{kmer()} to compute the reverse compliment kmer.The reverse compliment kmer is a variant of the basic kmer, in which the kmers are not expected to be strand-specific, so reverse complements are collapsed into a single feature. For example, if k=2, there are totally 16 basic kmers ('AA', 'AC', 'AG', 'AT', 'CA', 'CC', 'CG', 'CT', 'GA', 'GC', 'GG', 'GT', 'TA', 'TC', 'TG', 'TT'), but by removing the reverse compliment kmers, there are only 10 distinct kmers in the reverse compliment kmer approach ('AA', 'AC', 'AG', 'AT', 'CA', 'CC', 'CG', 'GA', 'GC', 'TA'). For more information of this approach, please refer to \citep{noble2005predicting} \citep{gupta2008predicting}.

%
<<reverse compliment kmer>>=
kmer(x, k = 2, reverse = TRUE)
@
%

\subsection{Increment of diversity}\label{subsec:IncDiv}

The increment of diversity has been successfully applied in the prediction of exonintron splice sites for several model genomes \cite{zhang2003splice}, transcription start site prediction, and studying the organization of nucleosomes around splice sites \cite{lu2008prediction}.
In this method, the sequence features are converted into the increment of diversity \textbf(ID), defined by the relation of sequence X with standard source S:

$$
ID = Diversity(X + S ) - Diversity(S) - Diversity(X)
$$

Given a sequence $X$ with $r$ feature variables ($ID_1$ to $IDr$), we obtain an r-dimensional
feature vector \textbf{R} = ($ID_1$, $ID_2$, \ldots, $ID_r$) . The feature vector \textbf{R} is designed by the
following considerations. The kmers are responsible for the discrimination between positive samples and negative samples, and therefore they construct the diversity sources. Based on this, 2 kmer-based increments of diversities $ID_1$ ($ID_2$) between sequence \code{X} and the standard source in positive (negative) training set can be easily introduced as the feature vectors.
9
For more information of this approach, please refer to \citep{chen2010organization} and \citep{liu2012sequence}.

%
<<Increment of diversity>>=
pos = readFASTA(system.file('dnaseq/hs.fasta', package = 'rDNAse'))
neg = readFASTA(system.file('dnaseq/non-hs.fasta', package = 'rDNAse'))
make_idkmer_vec(k = 6, x, pos, neg)
@
%

\section{Autocorrelation}\label{sec:autocorrelation}\addcontentsline{toc}{section}{4. Autocorrelation}

Autocorrelation, as one of the multivariate modeling tools, can transform the DNA sequences of different lengths into fixed-length vectors by measuring the correlation between any two properties. Autocorrelation results in two kinds of variables: autocorrelation \code{AC} between the same property, and cross-covariance \code{CC} between two different properties. Module \textbf{ac} (ac is the abbreviation of autocorrelation) in rDNAse allows the users to generate various kinds of autocorrelation feature vectors for given DNA sequences or FASTA files by selecting different methods and parameters. This module aims at computing six types of autocorrelation, including dinucleotide-based auto covariance \code{DAC}, dinucleotide-based cross covariance \code{DCC}, dinucleotide-based auto-cross covariance \code{DACC}, trinucleotide-based auto covariance \code{TAC}, trinucleotide-based cross covariance \code{TCC}, and trinucleotide-based auto-cross covariance \code{TACC}. Let's introduce them one by one.

\subsection{Dinucleotide-based auto covariance}\label{subsec:dac}

Suppose a DNA sequence \textbf{D} with \boldmath $L$ nucleic acid residues; i.e.

$$
\textbf{D} = {R_1} {R_2}{R_3}{R_4}{R_5}{R_6}{R_7} \ldots {R_L}
$$

where ${R_1}$ represents the nucleic acid residue at the sequence position 1, ${R_2}$ the
nucleic acid residue at position 2 and so forth.
The \code{DAC} measures the correlation of the same physicochemical index between two dinucleotide separated by a distance of lag along the sequence, which can be calculated as:

$$
DAC(u,lag)=\sum_{i=1}^{L-lag - 1} \frac{({P_u} ({R_{i} R_{i+1}}) - \bar{P_u}) ({{P_u} ({R_{i+lag} R_{i+lag+1}}) - \bar{P_u}})} {L-lag - 1}
$$

where $u$ is a physicochemical index, \boldmath $L$ is the length of the DNA sequence, ${P_u} ({R_{i} R_{i+1}})$ means the numerical value of the physicochemical index $u$ for the dinucleotide ${R_{i} R_{i+1}}$ at position $i$, $\bar{P_u}$ sequence: is the average value for physicochemical index $u$ along the whole sequence:

$$
\bar{P_u} = \sum_{j=1}^{L - 1}\frac{{P_u} ({R_{j} R_{j+1}})}{L -1}
$$

In such a way, the length of \code{DAC} feature vector is N $\ast$ LAG, where N is the number of physicochemical indices and LAG is the maximum of lag (lag = 1, 2,  $\ldots$, LAG).
This \code{DAC} approach is similar as the approach used for DNA fold recognition \citep{dong2009new}.

%
<<DAC>>=
extrDAC(x)

phyche_index = data.frame(cust1 = c(2.26, 3.03, 2.03, 3.83, 1.78, 1.65, 2.00, 
2.03, 1.93, 2.61, 1.65, 3.03, 1.20, 1.93, 1.78, 2.26), cust2 = c(7.65, 8.93, 
7.08, 9.07, 6.38, 8.04, 6.23, 7.08, 8.56, 9.53, 8.04, 8.93, 6.23, 8.56, 6.38, 
7.65))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(2, alphabet = "ACGT")
extrDAC(x, normaliztion = TRUE, customprops = customprops)
@
%

\subsection{Dinucleotide-based cross covariance}\label{subsec:DCC}

Given a DNA sequence D, the DCC approach measures the correlation of two different physicochemical indices between two dinucleotides separated by lag nucleic acids along the sequence, which can be calculated by:

$$
DCC(u_1, u_2, lag)=\sum_{i=1}^{L-lag - 1} \frac{({P_{u_1}} ({R_{i} R_{i+1}}) - \bar{P_{u_1}}) ({{P_{u_2}} ({R_{i+lag} R_{i+lag+1}}) - \bar{P_{u_2}}})} {L-lag - 1}
$$

where $u_1$, $u_2$ are two different physicochemical indices, \boldmath $L$ is the length of the DNA sequence, $ {P_{u_1}} ({R_{i} R_{i+1}}) ({P_{u_2}} ({R_{i} R_{i+1}})) $ is the numerical value of the physicochemical index $ {u_1} ({u_2})$ for the dinucleotide  at position $i$, $\bar{P_{u_1}}(\bar{P_{u_2}})$ is the average value for physicochemical index value $ u_1 $, $u_2$  along the whole sequence:

In such a way, the length of the DCC feature vector is N$\ast$(N-1)$\ast$LAG, where N is the number of physicochemical indices and LAG is the maximum of lag (lag=1, 2, $\ldots $, LAG).

This DCC approach is similar as the approach used for DNA fold recognition \citep{dong2009new}.

%
<<DCC>>=
extrDCC(x)

phyche_index = data.frame(cust1 = c(2.26, 3.03, 2.03, 3.83, 1.78, 1.65, 2.00, 
2.03, 1.93, 2.61, 1.65, 3.03, 1.20, 1.93, 1.78, 2.26), cust2 = c(7.65, 8.93, 
7.08, 9.07, 6.38, 8.04, 6.23, 7.08, 8.56, 9.53, 8.04, 8.93, 6.23, 8.56, 6.38, 
7.65))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(2, alphabet = "ACGT")
extrDCC(x, normaliztion = TRUE, customprops = customprops)
@
%

\subsection{Dinucleotide-based auto-cross covariance}\label{subsec:DACC}

DACC is a combination of DAC and DCC. Therefore, the length of the DACC feature vector is N$\ast$N$\ast$LAG, where N is the number of physicochemical indices and LAG is the maximum of lag (lag = 1, 2, $\ldots $, LAG).

%
<<DACC>>=
extrDACC(x)

phyche_index = data.frame(cust1 = c(2.26, 3.03, 2.03, 3.83, 1.78, 1.65, 2.00, 
2.03, 1.93, 2.61, 1.65, 3.03, 1.20, 1.93, 1.78, 2.26), cust2 = c(7.65, 8.93, 
7.08, 9.07, 6.38, 8.04, 6.23, 7.08, 8.56, 9.53, 8.04, 8.93, 6.23, 8.56, 6.38, 
7.65))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(2, alphabet = "ACGT")
extrDACC(x, normaliztion = TRUE, customprops = customprops)
@
%

\subsection{Trinucleotide-based auto covariance}\label{subsec:TAC}

Given a DNA sequence $D$, the TAC approach measures the correlation of the same physicochemical index between two trinucleotides separated by \boldmath $lag$ nucleic acids along the sequence, which can be calculated as:

$$
TAC(u,lag)=\sum_{i=1}^{L-lag - 2} \frac{({P_u} ({R_{i} R_{i+1}R_{i+2}}) - \bar{P_u}) ({{P_u} ({R_{i+lag} R_{i+lag+1}R_{i+lag+2}}) - \bar{P_u}})} {L-lag - 2}
$$

where $u$ is a physicochemical index, \boldmath $L$ is the length of the DNA sequence, ${P_u} ({R_{i} R_{i+1}R_{i+2}})$ represents the numerical value of the physicochemical index $u$ for the trinucleotide ${R_{i} R_{i+1}R_{i+2}}$ at position $i$, $\bar{P_u}$ is the average value for physicochemical index $u$ value along the whole sequence:

$$
\bar{P_u} = \sum_{j=1}^{L - 2}\frac{{P_u} ({R_{j} R_{j+1}R_{j+2}})}{L -2}
$$

In such a way, the length of TAC feature vector is N$\ast$LAG, where N is the number of physicochemical indices and LAG is the maximum of lag (lag=1, 2, $\ldots $, LAG).

%
<<TAC>>=
extrTAC(x)
phyche_index = data.frame(cust = c(7.176, 6.272, 4.736, 7.237, 3.810, 4.156, 
4.156, 6.033, 3.410, 3.524, 4.445, 6.033, 1.613, 5.087, 2.169, 7.237, 3.581, 
3.239, 1.668, 2.169, 6.813, 3.868, 5.440, 4.445, 3.810, 4.678, 5.440, 4.156, 
2.673, 3.353, 1.668, 4.736, 4.214, 3.925, 3.353, 5.087, 2.842, 2.448, 4.678, 
3.524, 3.581, 2.448, 3.868, 4.156, 3.467, 3.925, 3.239, 6.272, 2.955, 3.467, 
2.673, 1.613, 1.447, 3.581, 3.810, 3.410, 1.447, 2.842, 6.813, 3.810, 2.955, 
4.214, 3.581, 7.176))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(3, alphabet = "ACGT")
extrTAC(x, normaliztion = TRUE, customprops = customprops)
@
%

\subsection{Trinucleotide-based cross covariance}\label{subsec:TCC}

Given a DNA sequence $D$, the TCC approach measures the correlation of two different physicochemical indices between two trinucleotides separated by lag nucleic acids along the sequence, which can be calculated by:

$$
TCC(u_1, u_2, lag)=\sum_{i=1}^{L-lag - 2} \frac{({P_{u_1}} ({R_{i} R_{i+1}R_{i+2}}) - \bar{P_{u_1}}) ({{P_{u_2}} ({R_{i+lag} R_{i+lag+1}R_{i+lag+2}}) - \bar{P_{u_2}}})} {L-lag - 2}
$$

where $u_1$, $u_2$ are two physicochemical indices, \boldmath $L$  is the length of the DNA sequence,${P_{u_1}} ({R_{i} R_{i+1}R_{i+2}})$ $({P_{u_2}} ({R_{i} R_{i+1}R_{i+2}}))$ represents the numerical value of the physicochemical index $u_1 (u_2)$ for the trinucleotide $R_{i} R_{i+1} R_{i+2}$ at position $i$, 

$$
\bar{P_u} = \sum_{j=1}^{L - 2}\frac{{P_u} ({R_{j} R_{j+1}R_{j+2}})}{L - 2}
$$

In such a way, the length of TCC feature vector is N$\ast$(N-1)$\ast$LAG, where N is the number of physicochemical index and LAG is the maximum of lag (lag = 1, 2,  $\ldots $, LAG).

%
<<TCC>>=
extrTCC(x)

phyche_index = data.frame(cust = c(7.176, 6.272, 4.736, 7.237, 3.810, 4.156, 
4.156, 6.033, 3.410, 3.524, 4.445, 6.033, 1.613, 5.087, 2.169, 7.237, 3.581, 
3.239, 1.668, 2.169, 6.813, 3.868, 5.440, 4.445, 3.810, 4.678, 5.440, 4.156, 
2.673, 3.353, 1.668, 4.736, 4.214, 3.925, 3.353, 5.087, 2.842, 2.448, 4.678, 
3.524, 3.581, 2.448, 3.868, 4.156, 3.467, 3.925, 3.239, 6.272, 2.955, 3.467, 
2.673, 1.613, 1.447, 3.581, 3.810, 3.410, 1.447, 2.842, 6.813, 3.810, 2.955, 
4.214, 3.581, 7.176))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(3, alphabet = "ACGT")
extrTCC(x, normaliztion = TRUE, customprops = customprops)
@
%

\subsection{Trinucleotide-based auto-cross covariance}\label{subsec:TACC}

TACC is a combination of TAC and TCC. Therefore, the length of the TACC feature vector is N$\ast$N$\ast$LAG, where N is the number of physicochemical indices and LAG is the maximum of lag (lag = 1, 2, $\ldots $, LAG).

%
<<TACC>>=
extrTACC(x)

phyche_index = data.frame(cust = c(7.176, 6.272, 4.736, 7.237, 3.810, 4.156,
4.156, 6.033, 3.410, 3.524, 4.445, 6.033, 1.613, 5.087, 2.169, 7.237, 3.581, 
3.239, 1.668, 2.169, 6.813, 3.868, 5.440, 4.445, 3.810, 4.678, 5.440, 4.156, 
2.673, 3.353, 1.668, 4.736, 4.214, 3.925, 3.353, 5.087, 2.842, 2.448, 4.678, 
3.524, 3.581, 2.448, 3.868, 4.156, 3.467, 3.925, 3.239, 6.272, 2.955, 3.467, 
2.673, 1.613, 1.447, 3.581, 3.810, 3.410, 1.447, 2.842, 6.813, 3.810, 2.955, 
4.214, 3.581, 7.176))
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(3, alphabet = "ACGT")
extrTACC(x, normaliztion = TRUE, customprops = customprops)
@
%

\section{Pseudo nucleic acid composition}\label{sec:pseudo}\addcontentsline{toc}{section}{5. Pseudo nucleic acid composition}

PseNAC is a kind of powerful approaches to represent the DNA sequences considering both DNA local sequence-order information and long range or global sequence-order effects. Module psenac (psenac is the abbreviation of pseudo nucleic acid composition) in repDNA allows users to generate various kinds of PseNAC- based feature vectors for given sequences or FASTA files by selecting different methods and parameters. This module aims at computing six types of pseudo nucleic acid composition: pseudo dinucleotide composition (PseDNC), pseudo k-tuple nucleotide composition (PseKNC), parallel correlation pseudo dinucleotide composition (PC-PseDNC), parallel correlation pseudo trinucleotide composition (PC-PseTNC), series correlation pseudo dinucleotide composition (SC-PseDNC), and series correlation pseudo trinucleotide composition (SC-PseTNC). Let's introduce them one by one.

\subsection{Pseudo dinucleotide composition}\label{subsec:pseDNC}

PseDNC is an approach incorporating the contiguous local sequence-order information and the global sequence-order information into the feature vector of the DNA sequence.

Given a DNA sequence $\mathbf{D}$, the feature vector of $\mathbf{D}$ is defined:

$$
\mathbf{D} =[d_1 d_2 \ldots d_{16} d_{16+1}  \ldots d_{16+\lambda}]^{T}
$$

where

$$
d_{k} = \left\{ \begin{array}{lcl}
\displaystyle\frac{f_{k}}{\sum_{i=1}^{16}{f_{i}} + w \sum_{j = 1}^{\lambda}{\theta_{j}}} & \textrm{$1 \leq k \leq 16$}\\
\displaystyle\frac{w \theta_{k - 16}}{\sum_{i=1}^{16}{f_{i}} + w \sum_{j = 1}^{\lambda}{\theta_{j}}} & \textrm{$17 \leq k \leq {16+\lambda}$}\\
  \end{array} \right.
$$

where $f_{k}$ (k = 1, 2, $\ldots$, 16) is the normalized occurrence frequency of dinucleotide in the DNA sequence; the parameter $\lambda$ is an integer, representing the highest counted rank(or tier) of the correlation along a DNA sequence; $w$ is the weight factor ranged from 0 to 1; $\theta_{j}$ (j = 1, 2, $\ldots$, $\lambda$) is called the j-tier correlation factor that reflects the sequence order correlation between all the most contiguous dinucleotide along a DNA sequence, which is defined:

$$
\left\{ \begin{array}{ll}
\displaystyle\theta_{1} = \frac{1}{L-2}\sum_{i=1}^{L-2}\Theta(R_{i} R_{i+1}, R_{i+1} R_{i+2})\\
\displaystyle\theta_{2} = \frac{1}{L-3}\sum_{i=1}^{L-3}\Theta(R_{i} R_{i+1}, R_{i+2} R_{i+3}) \\
 & \textrm{$\lambda < L$}\\
\displaystyle\theta_{3} = \frac{1}{L-4}\sum_{i=1}^{L-4}\Theta(R_{i} R_{i+1}, R_{i+3} R_{i+4}) \\
\displaystyle\ldots\\
\displaystyle\theta_{1} = \frac{1}{L-1-\lambda}\sum_{i=1}^{L-1- \lambda}\Theta(R_{i} R_{i+1}, R_{i+\lambda} R_{i+\lambda+1})\\
  \end{array} \right.
$$

where the correlation function is given by

$$
\Theta(R_{i} R_{i+1}, R_{j} R_{j+1}) = \frac{1}{u}\sum_{u=1}^{u}[P_{u}(R_{i} R_{i+1}) - P_{u}(R_{j} R_{j+1})]^{2}
$$

where $\mu$ is the number of physicochemical indices, in this study, 6 indices reflecting the local DNA structural properties were employed to generate the PseDNCfeature vector;$P_{u}(R_{i} R_{i+1})$ represents the numerical value of the u-th (u = 1, 2, $\ldots$, $\mu$) physicochemical index of the dinucleotide $R_{i} R_{i+1}$ at position $i$ and $P_{u}(R_{j} R_{j+1})$ represents the corresponding value of the dinucleotide $R_{j} R_{j+1}$ at position $j$. For more information about this approach, please refer to \citep{chen2013irspot}.

%
<<PseDNC>>=
extrPseDNC(x)

phyche_index = data.frame(cust1 = c(1.019, -0.918, 0.488, 0.567, 0.567, 
-0.070, -0.579, 0.488, - 0.654, -2.455,-0.070, -0.918, 1.603, -0.654, 
0.567, 1.019)) 
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(2, alphabet = "ACGT")
extrPseDNC(x, normalize = TRUE, customprops = customprops, lambda = 2, 
w = 0.1)
@
%

\subsection{Pseudo k-tupler composition}\label{subsec:pseKNC}

PseKNC improved the PseDNC approach by incorporating k-tuple nucleotide composition.
Given a DNA sequence $\mathbf{D}$, the feature vector of $\mathbf{D}$ is defined:

$$
\mathbf{D} =[d_1 d_2 \ldots d_{4^{k}} d_{4^{k}+1}  \ldots d_{4^{k}+\lambda}]^{T}
$$

$$
d_{u} = \left\{ \begin{array}{lcl}
\displaystyle\frac{f_{u}}{\sum_{i=1}^{4^{k}}{f_{i}} + w \sum_{j = 1}^{\lambda}{\theta_{j}}} & \textrm{$1 \leq u \leq 4^{k}$}\\
\displaystyle\frac{w \theta_{u - 4^{k}}}{\sum_{i=1}^{4^{k}}{f_{i}} + w \sum_{j = 1}^{\lambda}{\theta_{j}}} & \textrm{$4^{k} \leq u \leq {4^{k}+\lambda}$}\\
  \end{array} \right.
$$

where $\lambda$ is the number of the total counted ranks (or tiers) of the correlations along a DNA sequence; $f_{u}$ (u = 1, 2, $\ldots$, $4^{k}$) is the frequency of oligonucleotide that is normalized to  $\sum_{i = 1}^{4^{k}}{f_{i} = 1}$; $w$  is a weight factor; $\theta_{j}$ is given by:

$$
\theta_{j} = \frac{1}{L-j-1}\sum_{i=1}^{L-j-1}{\Theta(R_{i} R_{i_1}, R_{i+j} R_{i+j+1})} \qquad
\textrm{$j = 1, 2, \ldots, \lambda; \lambda < L$}
$$

which represents the j-tier structural correlation factor between all the $j^{th}$ most contiguous dinucleotides. The correlation function $\Theta(R_{i} R_{i_1}, R_{i+j} R_{i+j+1})$ is defined by 

$$
\Theta(R_{i} R_{i+1}, R_{i+j} R_{i+j+1}) = \frac{1}{u}\sum_{v=1}^{u}[P_{v}(R_{i} R_{i+1}) - P_{v}(R_{i+j} R_{i+j+1})]^{2}
$$

where $\mu$ is the number of physicochemical indices, in this study, 6 indices reflecting the local DNA structural properties were employed to generate the PseKNC feature vector; $P_{v}(R_{i} R_{i+1})$ represents the numerical value of the $v$-th (u = 1, 2, $\ldots, \mu$) physicochemical indices for the dinucleotide $R_{i} R_{i+1}$ at position $i$ and $P_{v}(R_{i+j} R_{i+j+1})$ represents the corresponding value for the dinucleotide $R_{i+j} R_{i+j+1}$ atposition $i+j$. For more information about this approach, please refer to \citep{guo2014inuc}.

%
<<PsekNC>>=
extrPseKNC(x)

phyche_index = data.frame(cust1 = c(1.019, -0.918, 0.488, 0.567, 0.567, 
-0.070, -0.579, 0.488, - 0.654, -2.455,-0.070, -0.918, 1.603, -0.654, 
0.567, 1.019)) 
customprops = t(phyche_index)
colnames(customprops) = make_kmer_index(2, alphabet = "ACGT")
extrPseKNC(x, normalize = TRUE, customprops = customprops, lambda = 1, 
w = 0.05, k = 2)
@
%

\section{Similarity Calculation by Sequence Alignment}\addcontentsline{toc}{section}{6. Similarity Calculation by Sequence Alignment}

Similarity computation derived by local or global DNA sequence alignment between a list of DNA sequences is great need in the DNA related research and applications. However, this sort of pairwise similarity computation often computationally intensive, especially when there exists many DNA sequences. Luckily, this process is also highly parallelizable, the \pkg{rDNAse} package integrates the function of parallelized similarity computation derived by local or global DNA sequence alignment between a list of DNA sequences.

The function \code{twoSeqSim()} calculates the alignment result between two DNA sequences, and the function \code{parSeqSim()} calculates the pairwise similarity calculation with a list of DNA sequences in parallel:

\begin{CodeInput}
> s1 = readFASTA(system.file('dnaseq/P00750.fasta', package = 'rDNAse'))[[1]]
> s2 = readFASTA(system.file('dnaseq/P08218.fasta', package = 'rDNAse'))[[2]]
> s3 = readFASTA(system.file('dnaseq/P10323.fasta', package = 'rDNAse'))[[3]]
> s4 = readFASTA(system.file('dnaseq/P20160.fasta', package = 'rDNAse'))[[4]]
> s5 = readFASTA(system.file('dnaseq/Q9NZP8.fasta', package = 'rDNAse'))[[5]]
> plist   = list(s1, s2, s3, s4, s5)
> psimmat = parSeqSim(plist, cores = 4, type = 'local', submat = 'BLOSUM62')
> print(psimmat)
\end{CodeInput}

\begin{CodeOutput}
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 0.3330758 0.2763540 0.3044898 0.3408780
[2,] 0.3330758 1.0000000 0.3321031 0.3272556 0.3134858
[3,] 0.2763540 0.3321031 1.0000000 0.2962784 0.3000359
[4,] 0.3044898 0.3272556 0.2962784 1.0000000 0.2944940
[5,] 0.3408780 0.3134858 0.3000359 0.2944940 1.0000000
\end{CodeOutput}

It should be noted that for a small number of DNAs, calculating their pairwise similarity scores derived by sequence alignment in parallel may not significantly reduce the overall computation time, since each of the task only requires a relatively small time to finish, thus, computational overheads may exist and affect the performance. In testing, we used about 1,000 DNA sequences on 64 CPU cores, and observed significant performance improvement comparing to the sequential computation.

Users should install the packages \pkg{foreach} and \pkg{doParallel} before using \code{parSeqSim()}, according to their operation system. The \pkg{rDNAse} package will automatically decide which backend to use.

\section{Similarity Calculation by GO Semantic Similarity Measures}\addcontentsline{toc}{section}{7. Similarity Calculation by GO Semantic Similarity Measures}

The \pkg{rDNAse} package also integrates the function of similarity score computation derived by Gene Ontology (GO) semantic similarity measures between a list of GO terms / Entrez Gene IDs.

The function \code{twoGOSim()} calculates the similarity derived by GO-terms semantic similarity measures between two GO terms / Entrez Gene IDs, and the function \code{parGOSim()} calculates the pairwise similarity with a list of GO terms / Entrez Gene IDs:

\begin{CodeInput}
# by GO Terms
> go1 = c('GO:0005215', 'GO:0005488', 'GO:0005515',
+         'GO:0005625', 'GO:0005802', 'GO:0005905')  # AP4B1
> go2 = c('GO:0005515', 'GO:0005634', 'GO:0005681',
+         'GO:0008380', 'GO:0031202')                # BCAS2
> go3 = c('GO:0003735', 'GO:0005622', 'GO:0005840',
+         'GO:0006412')                              # PDE4DIP
> glist = list(go1, go2, go3)
> gsimmat1 = parGOSim(glist, type = 'go', ont = 'CC')
> print(gsimmat1)
\end{CodeInput}

\begin{CodeOutput}
      [,1]  [,2]  [,3]
[1,] 1.000 0.077 0.055
[2,] 0.077 1.000 0.220
[3,] 0.055 0.220 1.000
\end{CodeOutput}

\begin{CodeInput}
# by Entrez gene id
> genelist = list(c('150', '151', '152', '1814', '1815', '1816'))
> gsimmat2 = parGOSim(genelist, type = 'gene')
> print(gsimmat2)
\end{CodeInput}

\begin{CodeOutput}
       150   151   152  1814  1815  1816
150  0.689 0.335 0.487 0.133 0.169 0.160
151  0.335 0.605 0.441 0.171 0.198 0.274
152  0.487 0.441 0.591 0.151 0.178 0.198
1814 0.133 0.171 0.151 0.512 0.401 0.411
1815 0.169 0.198 0.178 0.401 0.619 0.481
1816 0.160 0.274 0.198 0.411 0.481 0.819
\end{CodeOutput}

\section{Miscellaneous Tools }\label{sec:tools}\addcontentsline{toc}{section}{8. Miscellaneous Tools }

In this section, we will briefly introduce some useful tools provided by the \pkg{rDNAse} package.

\subsection{Retrieve DNA Sequences from UniProt}

This function \code{getGenbank()} gets DNA sequences from Genbank by GI ID(s). The input \code{ID} is a character vector specifying the GI ID(s). The returned sequences are stored in a list:

%
\begin{CodeChunk}

\begin{CodeInput}
> ids = c('2', '392893239', '357180087')
> dnas = getGenbank(ids)
> print(dnas)
\end{CodeInput}

\begin{CodeOutput}
$gi_2
[1] "AATTCATGCGTCCGGACTTCTGCCTCGAGCCGCCGTACACTGGGCCCTGCAAAGCTCGTATCATCCGTTACT
TCTACAATGCAAAGGCAGGCCTGTGTCAGACCTTCGTATACGGCGGTTGCCGTGCTAAGCGTAACAACTTCAAATCC
GCGGAAGACTGCGAACGTACTTGCGGTGGTCCTTAGTAAAGCTTG"

$gi_392893239
[1] "GCCTAAAGACGACCGCGACGCGGCCGCTCGCACTCATAGACTACGCTAGTGGTGAGATACGCAGAGAAAAAG
ACGAGAGAGTATTGAGAGAATGGAGACATCACTACATCTAACATAGGGTCGCCAGTCGTCACCGAATTATTGGATTC
AAATTTAGGTCCC"

$gi_357180087
[1] "TTAAAGGGGACGTGGCCATTGGCCAGCTCACAGGCCGTGATTCCCACACTGTAGATGTCAGACTTGGCATCG
TAACCCTGGAGATTCTGCTGGAGGACCTCTGGGCTGAGCCAGGGCAGAACCTTGATACTGTACTTGGGGAAGTCGTG
GACCACACGCTGCCGCTGCCCGTGGCTGATCATGCTGAGGTTGCTTCGTAAACCTGACAGGTAGACCTTCCCATCAG
CGGAGATCAGAACGTGGCTGGCTTTGACGCTCCTGTGCACGTAGCCCATGTGGTGGATGTAATCCAAGGCCTTGAGC
GCCCCCTGCAGGATGTAAGCGATGGCCAGCTCGCTCATGCCGTCCATGAAGTGCGTGCAGATGAGGTCCTTGGCCGA
GCCGTATGCCATGAACGACGTGACGACCCACAGCTCGTTGTCCGCGATGAAGGTGGCTCCGTAGGGCAGGATGTTGG
GGTGGCTGAAGAGTTTAGAGACATGGAGTTCCCCCTGTAAGAACGTCACCATCTCGTTGGAGCAAGCCTCGAGGTTA
ATCCTTCGTACCGTCACATACTCCCCTGTTGGTTTGTACCTTGCTAGATTCACTGTCATCAGGTCCTCGAATCCTTT
GCCTATAACGGTGAGCAGCTCATAACACCCTCCCTCTGGCAGGAAGCTACTCATGATCTCCGGCTTAGAGAAGGGTG
CTATCGACTCTGAGCTCGCCTCATTGGTAAGAAAAGACATGAGTTCCTAACGTGTAGACCTACTTCAATTTCAAAAA
TTTAAACCTGGTCCTGGAGTTAGCAAGCAGTCCCGGCCCAGTCTCAGCTCCGCCTCCTTGGGTTAAGGCCCG"
\end{CodeOutput}
\end{CodeChunk}
%

\subsection{Read FASTA Format files}

The \code{readFASTA()} function provides a convenient way to read DNA sequences stored in FASTA format files. See \code{?readFASTA} for details. The returned sequences are stored in a named list, whose components are named with the DNA sequences' names.

\subsection{Sanity Check of the Deoxyribonucleic Acid Types}

The \code{dnacheck()} function checks if the DNA sequence's deoxyribonucleic acids types are in the 4 default types, which returns a \code{TRUE} if all the deoxyribonucleic acids in the sequence belongs to the 4 default types:

%
<<dnacheck>>=
x = readFASTA(system.file('dnaseq/hs.fasta', package = 'rDNAse'))[[1]]
# A real sequence
dnacheck(x)
# An artificial sequence
dnacheck(paste(x, 'Z', sep = ''))
@
%


\section{Summary}\addcontentsline{toc}{section}{9. Summary}

The summary of the descriptors in the \pkg{rDNAse} package is listed in table \ref{tab:all}.

\begin{table}[htbp]
  \centering
  \caption{List of commonly used descriptors in \pkg{rDNAse}}
  \scriptsize{
    \begin{tabular}{p{100pt}p{150pt}p{80pt}p{70pt}}
    \addlinespace
    \toprule
    Descriptor Group & Descriptor Name & Descriptor Dimension & Function Name\\
    \midrule
    Nucleic acid composition & Basic kmer & 16\footnotemark[1] & \code{kmer()} \\
          & Reverse compliment kmer & 10\footnotemark[1] & \code{kmer()} \\
          & Increment of diversity  & 12\footnotemark[2] & \code{make_idkmer_vec()} \\
    Autocorrelation & Dinucleotide-based auto covariance  & 4\footnotemark[3]  & \code{extrDAC()} \\
          & Dinucleotide-based cross covariance  & 4\footnotemark[3] & \code{extrDCC()} \\
          & Dinucleotide-based auto-cross covariance & 8\footnotemark[3] & \code{extrDACC()} \\
          & Trinucleotide-based auto covariance & 4\footnotemark[3]  & \code{extrTAC()} \\
          & Trinucleotide-based cross covariance & 4\footnotemark[3] & \code{extrTCC()} \\
          & Trinucleotide-based auto-cross covariance & 8\footnotemark[3] & \code{extrTACC()} \\
    Pseudo nucleotide composition & Pseudo dinucleotide composition  & 19\footnotemark[4] & \code{extrPseDNC()} \\
          & Pseudo k-tupler nucleotide composition & 65\footnotemark[5] & \code{extrPseKNC()} \\
           Similarity calculation  & Sequence alignment  &  & \code{parSeqSim()} \\
          & GO semantic similarity measures &  & \code{parGOSim()} \\
    \bottomrule
    \end{tabular}
  }
  \label{tab:all}
\end{table}

\footnotetext[1]{The number depends on the choice of the k value of kmer. The default is \code{k} = 2.}

\footnotetext[2]{The number depends on the choice of the k value of kmer. The default is \code{k} = 6.}

\footnotetext[3]{The number depends on the maximum value of \code{lag}. By default \code{lag} = 2. And the number of the physicochemical indices, By default the length of \code{index} = 2.}

\footnotetext[4]{The number depends on the maximum value of \code{lambda}. By default \code{lambda} = 3.}

\footnotetext[5]{The number depends on the maximum value of \code{lambda}. By default \code{lambda} = 1.}

The summary of the names of the 38 physicochemical indices for dinucleotides. in the \pkg{rDNAse} package is listed in table \ref{tab:all2}.

\begin{table}[htbp]
  \centering
  \caption{The names of the 38 physicochemical indices for dinucleotides}
  \footnotesize{
    \begin{tabular}{p{130pt}p{130pt}p{130pt}}
    \toprule
    Base stacking & DNA induced deformability & B-DNA twist \\
    Propeller twist & Propeller twist & Duplex stability: (freeenergy) \\
    DNA denaturation & Bending stiffness & DNA DNA twist \\
    Aida\_BA\_transition & Breslauer\_dG & Breslauer\_dH \\
    Electron\_interaction & Hartman\_trans\_free\_energy & Helix-Coil\_transition \\
    Lisser\_BZ\_transition & Polar\_interaction & SantaLucia\_dG \\
    SantaLucia\_dS &  Sarai\_flexibility & Stability \\
    Sugimoto\_dG & Sugimoto\_dH & Sugimoto\_dS \\
    Duplex tability (disruptenergy) & Stabilising energy of Z-DNA & Breslauer\_dS \\
    Ivanov\_BA\_transition & SantaLucia\_dH & Stacking\_energy \\
    Watson-Crick\_interaction & Dinucleotide GC Content & Twist \\
    Tilt & Roll & Shift \\
    Slide & Rose \\
    
    \bottomrule
    \end{tabular}
  }
  \label{tab:all2}
\end{table}

The summary of the names of the 12 physicochemical indices for trinucleotides. in the \pkg{rDNAse} package is listed in table \ref{tab:all3}.

\begin{table}[htbp]
  \centering
  \caption{The names of the 12 physicochemical indices for trinucleotides.}
  \footnotesize{
    \begin{tabular}{p{130pt}p{130pt}p{130pt}}
    \toprule
    Bendability (DNAse) & Bendability (consensus) & Trinucleotide GC Content \\
    Consensus\_roll & Consensus-Rigid & Dnase I \\
    MW-Daltons & MW-kg & Nucleosome \\
    Nucleosome positioning & Dnase I-Rigid & Nucleosome-Rigid \\ 
    \bottomrule
    \end{tabular}
  }
  \label{tab:all3}
\end{table}

The summary of the names of the 6 physicochemical indices for dinucleotides. in the \pkg{rDNAse} package is listed in table \ref{tab:all4}.

\begin{table}[!htbp]
  \centering
  \caption{The names of the 6 physicochemical indices for dinucleotides.}
  \footnotesize{
    \begin{tabular}{p{130pt}p{130pt}p{130pt}}
    \toprule
    Twist & Tilt & Roll \\
    Shift & Slide & Rise \\
    \bottomrule
    \end{tabular}
  }
  \label{tab:all4}
\end{table}

In this manual, we discussed the functions of the \pkg{rDNAse} package, which is trying to offer a comprehensive and unique toolkit for DNA sequence descriptor calculation and similarity computation.

\section*{Acknowledgments}

This work is financially supported by the National key basic research program (2015CB910700), the National Natural Science Foundation of China (Grants No. 81402853), grants from the Project of Innovation-driven Plan in Central South University, and the Postdoctoral Science Foundation of Central South University, the Chinese Postdoctoral Science Foundation (2014T70794, 2014M562142). The studies meet with the approval of the university's review board.

\clearpage

\nocite{*} % list uncited bibs
\bibliography{rDNAse}

\vspace*{-0.35cm}

\end{document}
